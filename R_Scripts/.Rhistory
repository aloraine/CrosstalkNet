m[4]
m[5]
m[1,1]
m[2,2]
vignette(caret)
caret
library(caret)
vignette(caret)
vignette(package="caret")
vignette(package="caret")
vignette(package="ggplot2")
help(package="caret")
help(package="caret")
vignette(caret)
vignette(package="caret")
vignette(package="caret")
openVignette("caret")
help(package="caret")
vignette(package="caret")
vignette("caret")
args(vignette)
vignette(topic="caret")
library("ISLR")
data("iris")
plot(iris)
library(caret)
featurePlot(x=iris[, c("Petal.Width", "Petal.Length")], y=iris$Species, plot="pairs")
featurePlot(x=iris[, c("Sepal.Width", "Petal.Length")], y=iris$Species, plot="pairs")
featurePlot(x=iris[, c("Sepal.Width", "Petal.Length")], y=iris$Species, plot="pairs")
plot(iris$Species, iris$Sepal.Length)
help(plot)
plot(iris$Species, iris$Sepal.Length, type="p")
data("Wage")
qq <- qplot(age, wage, colour=education, data=training)
qq + geom_smooth(method="lm", formula=y~x)
help(qplot)
qplot(age, wage, colour=education, data=training, geom="density")
qplot(wage, colour=education, data=training, geom="density")
lml <- lm(wage ~ logwage, data=Wage)
lml
plot(Wage$wage, Wage$logwage, pch=19, cex=0.5)
data(Wage)
inBuild <- createDataPartition(y=Wage$wage, p=0.7, list=FALSE)
validation <- Wage[-inBuild,]
buildData <- Wage[inBuild,]
inTrain <- createDataPartition(y=buildData$wage, p=0.7,list=FALSE)
training <- buildData[inTrain,]
testing <- buildData[-inTrain,]
mod1 <- train(wage ~ ., method="glm", data = training)
mod2 <- train(wage ~ ., method="rpart", data=training,
trControl = trainControl(method="cv"), numbers = 3)
mod2 <- train(wage ~ ., method="rf", data=training,
trControl = trainControl(method="cv"), numbers = 3)
mod2 <- train(wage ~ ., method="rf", data=training,
trControl = trainControl(method="cv"), numbers = 3)
mod2 <- train(wage ~ ., method="rf", data=training,
trControl = trainControl(method="cv"), numbers = 3)
library(caret)
library(ISLR)
library(randomForest)
data(Wage)
inBuild <- createDataPartition(y=Wage$wage, p=0.7, list=FALSE)
validation <- Wage[-inBuild,]
buildData <- Wage[inBuild,]
inTrain <- createDataPartition(y=buildData$wage, p=0.7,list=FALSE)
training <- buildData[inTrain,]
testing <- buildData[-inTrain,]
mod1 <- train(wage ~ ., method="glm", data = training)
mod2 <- train(wage ~ ., method="rf", data=training,
trControl = trainControl(method="cv"), numbers = 3)
mod2
mod2 <- train(wage ~ ., method="rf", data=training,
trControl = trainControl(method="cv", numbers = 3)
mod2 <- train(wage ~ ., method="rf", data=training,
trControl = trainControl(method="cv", numbers = 3))
mod2 <- train(wage ~ ., method="rf", data=training,
trControl = trainControl(method="cv"), numbers = 3)
from.dat <- as.Date("01/01/08", format="%m/%d/%y")
to.dat <- as.Date("12/31/13", format="%m/%d/%y")
getSymbols("GOOG", src="google", from=from.dat, to=to.dat)
] "GOOG"
head(GOOG)
from.dat <- as.Date("01/01/08", format="%m/%d/%y")
to.dat <- as.Date("12/31/13", format="%m/%d/%y")
getSymbols("GOOG", src="google", from=from.dat, to=to.dat)
library(quantmod)
getSymbols("GOOG", src="google", from=from.dat, to=to.dat)
getSymbols("GOOG", src="google", from=from.dat, to=to.dat)
tempGoog <- GOOG[,-5]
mGoog <- to.monthly(tempGoog)
googOpen <- Op(mGoog)
ts1 <- ts(googOpen, frequency = 12)
plot(decompose(ts1), xlab="Years + 1")
ts1Train <- window(ts1, start=1, end=5)
ts1Test <- window(ts1, start=7, end=(7-0.01))
ts1Test <- window(ts1, start=5, end=(7-0.01))
ts1Train
ts1Train
plot(ts1)
lines(ma(ts1Train,order=3), col="re")
lines(ma(ts1Train,order=3), col="red")
library(caret)
lines(ma(ts1Train,order=3), col="red")
library(stats)
lines(ma(ts1Train,order=3), col="red")
lines(MA(ts1Train,order=3), col="red")
install.packages("forecast")
lines(ma(ts1Train,order=3), col="red")
library(forecast)
lines(ma(ts1Train,order=3), col="red")
lines(ma(ts1Train,order=6), col="red")
plot(ts1)
lines(ma(ts1Train,order=3), col="red")
x < c(1,2,3)
x <- c(1,2,3)
attributes(x)
len(x)
size(x)
dim(X)
dim(x)
legth(x)
length(x)
class(x)
is.vector(x)
is.numeric(x)
x <- vector("character", 5)
x
x <- data.frame( foo=c(1:4), bar=c("A","B","C","D"))
is.vector(x)
is.array(x)
is.atomic(x)
y = 4
is.atomic(y)
y <- c(1,2)
is.atomic(y)
x <- list(ard=c(1,2,3), arc=c(4,5,6))
x$a
x <- list(ard=c(1,2,3))
x$a
x <- list(ard=c(1,2,3), arc=c(4,5,6))
x$a
x[["a", exact=F]]
x = 5
if (x > 3) {
y <- 10
} else {
y <- 0
}
y <- if (x > 3) {
10
} else {
0
}
for (i in 1:10){
print(i)
}
i
x <- c("a","b","c","d")
for(i in 1:4) {
print(x[i])
}
for (i in seq_along(x)) {
print(x[i])
}
for (letter in x) {
print(letter)
}
for (i in 1:4) print(x[i])
sqe_along(x)
see_along(x)
seq_along(x)
x <- matrix(1:6, 2, 3)
for (i in seq_len(nrow(x))) {
for (j in seq_len(ncol(x))) {}
}
for (i in seq_len(nrow(x))) {
for (j in seq_len(ncol(x))) {
print(x[i,j])
}
}
x <- seq(length=10, by=0.5)
x
x <- seq(length=10, by=0.5, start=5)
help(seq)
seq(from=2,to=4,by=0.01)
help(rbinom)
dbinom(10,20,0.5)
choose(20,10)*0.5^10*0.5^10
install.packages("mcga")
install.packages("RCEIM")
install.packages("RcppDE")
library(ggplot2)
mtcars
qplot(mtcars$wt, mtcars$mpg)
qplot(wt, mpg, data=mtcars)
plot(pressure$temperature, pressure$pressure, type="l")
points(pressure$temperature, pressure$pressure)
lines(pressure$temperature, pressure$pressure/2, type="l")
plot(pressure$temperature, pressure$pressure, type="l")
points(pressure$temperature, pressure$pressure)
lines(pressure$temperature, pressure$pressure/2, type="l", col="re")
lines(pressure$temperature, pressure$pressure/2, type="l", col="red")
points(pressure$tempreature, pressure$pressure/2, col="red")
points(pressure$tempreature, pressure$pressure/2, col="red")
lines(pressure$temperature, pressure$pressure/2, type="l", col="red")
points(pressure$temperature, pressure$pressure/2, col="red")
qplot(pressure$temperature, pressure$pressure, geom="line")
table(mtcars$cyl)
barplot(table(mtcars$cyl))
qplot(BOD$Time, BOD$demand, geom="bar", stat="identity")
qplot(BOD$Time, BOD$demand, geom="bar")
qplot(mtcars$cyl
)
hist(mtcars$mpg)
qplot(mtcars$mpg)
qplot(mtcars$mpg, binwidth=5)
qplot(mtcars$mpg, binwidth=4)
boxplot(len - supp, data=ToothGrowth)
boxplot(len ~ supp, data=ToothGrowth)
qplot(ToothGrowth$supp, ToothGrowth$len, geom="boxplot")
curve(x^3, from=1, to=5)
library(plyr)
tg <- ddply(Too)
tg <- ddply(ToothGrowth, c("supp", "dose"), summarise, length=mean(len))
ggplot(tg, aes(x=dose, y=length, colour=supp))
x <- 1:2
x <- 1:20
str(X)
str(x)
attributes(x)
class(x)
x <- 1:2
names(x) <- C("a", "b")
x <- data.frame(a = 1:4, b = 5:8)
x
dim(x)
x <- 1:2
names(x)
names(x) <- c("a","b")
x
x$a
x <- list(1, "a", T)
x
names(x) <- C("a", "b", "c")
names(x) <- c("a", "b", "c")
x
x$a
library(ISLR)
row.names(USArrests)
head(USArrests)
states <- row.names(USArrests)
names(USArrests)
apply(USArrests, 2, mean)
apply(USArrests, 1, mean)
apply(USArrests, 2, var)
USArrests[USArrests$Rape > sd(USArrests$Rape) + mean(USArrests$Rape),]
mean(USArrests$Rape)
sd(USArrests$Rape)
USArrests[USArrests$Rape > 2*sd(USArrests$Rape) + mean(USArrests$Rape),]
USArrests[USArrests$Murder > 2*sd(USArrests$Murder) + mean(USArrests$Murder),]
USArrests[USArrests$Murder > sd(USArrests$Murder) + mean(USArrests$Murder),]
USArrests
pr.out <= prcomp(USArrests, scaled=TRUE)
pr.out <- prcomp(USArrests, scaled=TRUE)
pr.out
pr.out$sdev
x <- "a"
x
x[1]
x[300]
library('psych')
install.packages
setwd('C:/Users/Alex/Documents/angular-seed/R_Scripts')
load('TE-LGenes.RData')
load('TS-LGenes.RData')
View(edataTE.ERNeg.LGenes)
CorTES.LGenes <- cor(t(edataTE.ERNeg.LGenes),t(edataTS.ERNeg.LGenes))
CorTES.LGenes <- CorTES.LGenes[1:100, 1:100]
TESLGenes.padj.FDR <- p.adjust(Signif.TESLGenes$p,method="fdr",length(Signif.TESLGenes$p)) # FDR Adjustment for multiple testing
CorTESLGenes.FDRadj <- CorTES.LGenes
CorTESLGenes.FDRadj[TESLGenes.padj.FDR>0.05] <- 0
length(which(diag(CorTESLGenes.FDRadj)!=0)) # Number of self loops
length(which((CorTESLGenes.FDRadj)!=0)) # Num
Signif.TESLGenes<-r.test(54,CorTES.LGenes)
library(psych)
Signif.TESLGenes<-r.test(54,CorTES.LGenes)
TESLGenes.padj.FDR <- p.adjust(Signif.TESLGenes$p,method="fdr",length(Signif.TESLGenes$p)) # FDR Adjustment for multiple testing
CorTESLGenes.FDRadj <- CorTES.LGenes
CorTESLGenes.FDRadj[TESLGenes.padj.FDR>0.05] <- 0
length(which(diag(CorTESLGenes.FDRadj)!=0)) # Number of self loops
length(which((CorTESLGenes.FDRadj)!=0)) # Num
CorTESLGenes.FDRadj
class(CorTESLGenes.FDRadj)
getDegree <- function(corMatrix) {
deg.row <- as.numeric()
for(k in 1:nrow(corMatrix)){
deg.row[k] <- length(which(corMatrix[k,] != 0))
}
rownames(deg.row) <- rownames(corMatrix)
# cols
deg.col <- as.numeric()
for(k in 1:ncol(corMatrix)){
deg.col[k] <- length(which(corMatrix[,k] != 0))
}
colnames(deg.col) <- colnames(corMatrix)
}
getDegree(CorTESLGenes.FDRadj)
getDegree <- function(corMatrix) {
deg.row <- as.numeric()
for(k in 1:nrow(corMatrix)){
deg.row[k] <- length(which(corMatrix[k,] != 0))
}
dim(deg.row) <- length(deg.row)
rownames(deg.row) <- rownames(corMatrix)
# cols
deg.col <- as.numeric()
for(k in 1:ncol(corMatrix)){
deg.col[k] <- length(which(corMatrix[,k] != 0))
}
colnames(deg.col) <- colnames(corMatrix)
}
getDegree(CorTESLGenes.FDRadj)
getDegree <- function(corMatrix) {
deg.row <- as.numeric()
for(k in 1:nrow(corMatrix)){
deg.row[k] <- length(which(corMatrix[k,] != 0))
}
dim(deg.row) <- length(deg.row)
rownames(deg.row) <- rownames(corMatrix)
# cols
deg.col <- as.numeric()
for(k in 1:ncol(corMatrix)){
deg.col[k] <- length(which(corMatrix[,k] != 0))
}
dig(deg.col) <- length(deg.col)
colnames(deg.col) <- colnames(corMatrix)
}
getDegree(CorTESLGenes.FDRadj)
getDegree <- function(corMatrix) {
deg.row <- as.numeric()
for(k in 1:nrow(corMatrix)){
deg.row[k] <- length(which(corMatrix[k,] != 0))
}
dim(deg.row) <- length(deg.row)
rownames(deg.row) <- rownames(corMatrix)
# cols
deg.col <- as.numeric()
for(k in 1:ncol(corMatrix)){
deg.col[k] <- length(which(corMatrix[,k] != 0))
}
deg(deg.col) <- length(deg.col)
colnames(deg.col) <- colnames(corMatrix)
}
getDegree(CorTESLGenes.FDRadj)
getDegree <- function(corMatrix) {
deg.row <- as.numeric()
for(k in 1:nrow(corMatrix)){
deg.row[k] <- length(which(corMatrix[k,] != 0))
}
dim(deg.row) <- length(deg.row)
rownames(deg.row) <- rownames(corMatrix)
# cols
deg.col <- as.numeric()
for(k in 1:ncol(corMatrix)){
deg.col[k] <- length(which(corMatrix[,k] != 0))
}
dim(deg.col) <- length(deg.col)
colnames(deg.col) <- colnames(corMatrix)
}
getDegree(CorTESLGenes.FDRadj)
class(CorTESLGenes.FDRadj)
CorTESLGenes.FDRadj["4605"]
CorTESLGenes.FDRadj["4605"]["4605"]
CorTESLGenes.FDRadj
colNames(CorTESLGenes.FDRadj)
colnames(CorTESLGenes.FDRadj)
CorTESLGenes.FDRadj["4605",
]
CorTESLGenes.FDRadj["4605", which(CorTESLGenes.FDRadj["4605", ] != 0)
]
CorTESLGenes.FDRadj
CorTESLGenes.FDRadj["51635", which(CorTESLGenes.FDRadj["51635", ] != 0)
]
which(CorTESLGenes.FDRadj["51635", ] != 0)
CorTESLGenes.FDRadj["51635", "51635"]
CorTESLGenes.FDRadj["51635", "7027"]
CorTESLGenes.FDRadj["51635", 94]
CorTESLGenes.FDRadj["51635", which(CorTESLGenes.FDRadj["51635", ] != 0)
]
names(CorTESLGenes.FDRadj["51635", which(CorTESLGenes.FDRadj["51635", ] != 0)])
class(CorTESLGenes.FDRadj["51635", which(CorTESLGenes.FDRadj["51635", ] != 0)])
help(commandArgs)
setwd('C:/Users/Alex/Documents/angular-seed/R_Scripts')
load('TE-LGenes.RData')
load('TS-LGenes.RData')
View(edataTE.ERNeg.LGenes)
CorTES.LGenes <- cor(t(edataTE.ERNeg.LGenes),t(edataTS.ERNeg.LGenes))
Signif.TESLGenes<-r.test(54,CorTES.LGenes)
TESLGenes.padj.FDR <- p.adjust(Signif.TESLGenes$p,method="fdr",length(Signif.TESLGenes$p)) # FDR Adjustment for multiple testing
CorTESLGenes.FDRadj <- CorTES.LGenes
CorTESLGenes.FDRadj[TESLGenes.padj.FDR>0.05] <- 0
length(which(diag(CorTESLGenes.FDRadj)!=0)) # Number of self loops
length(which((CorTESLGenes.FDRadj)!=0)) # Number of significant loops in the network
Signif.TESLGenes<-r.test(54,CorTES.LGenes)
Signif.TESLGenes["51635",]
CorTESLGenes.FDRadj <- CorTES.LGenes
setwd('C:/Users/Alex/Documents/angular-seed/R_Scripts')
load('TE-LGenes.RData')
load('TS-LGenes.RData')
View(edataTE.ERNeg.LGenes)
CorTES.LGenes <- cor(t(edataTE.ERNeg.LGenes),t(edataTS.ERNeg.LGenes))
Signif.TESLGenes<-r.test(54,CorTES.LGenes)
TESLGenes.padj.FDR <- p.adjust(Signif.TESLGenes$p,method="fdr",length(Signif.TESLGenes$p)) # FDR Adjustment for multiple testing
CorTESLGenes.FDRadj <- CorTES.LGenes
CorTESLGenes.FDRadj[TESLGenes.padj.FDR>0.05] <- 0
length(which(diag(CorTESLGenes.FDRadj)!=0)) # Number of self loops
length(which((CorTESLGenes.FDRadj)!=0)) # Number of significant loops in the network
CorTESLGenes.FDRadj["51635",]
CorTESLGenes.FDRadj["51635", which(CorTESLGenes.FDRadj["51635", ] != 0)]
CorTESLGenes.FDRadj["51635", "51635"]
View(CorTESLGenes.FDRadj)
getDegree <- function(corMatrix) {
deg.row <- as.numeric()
for(k in 1:nrow(corMatrix)){
deg.row[k] <- length(which(corMatrix[k,] != 0))
}
#dim(deg.row) <- length(deg.row)
names(deg.row) <- rownames(corMatrix)
# cols
deg.col <- as.numeric()
for(k in 1:ncol(corMatrix)){
deg.col[k] <- length(which(corMatrix[,k] != 0))
}
#dim(deg.col) <- length(deg.col)
names(deg.col) <- colnames(corMatrix)
}
getDegree(CorTESLGenes.FDRadj)
getDegree <- function(corMatrix) {
deg.row <- as.numeric()
for(k in 1:nrow(corMatrix)){
deg.row[k] <- length(which(corMatrix[k,] != 0))
}
#dim(deg.row) <- length(deg.row)
names(deg.row) <- rownames(corMatrix)
# cols
deg.col <- as.numeric()
for(k in 1:ncol(corMatrix)){
deg.col[k] <- length(which(corMatrix[,k] != 0))
}
#dim(deg.col) <- length(deg.col)
names(deg.col) <- colnames(corMatrix)
result <- list(epiDegree <- deg.row, stromaDegree <- deg.col)
}
getDegree(CorTESLGenes.FDRadj)
res <- getDegree(CorTESLGenes.FDRadj)
res
setwd('C:/Users/Alex/Documents/angular-seed/R_Scripts')
load('TE-LGenes.RData')
load('TS-LGenes.RData')
View(edataTE.ERNeg.LGenes)
CorTES.LGenes <- cor(t(edataTE.ERNeg.LGenes),t(edataTS.ERNeg.LGenes))
#CorTES.LGenes <- CorTES.LGenes[1:100, 1:100]
Signif.TESLGenes<-r.test(54,CorTES.LGenes)
TESLGenes.padj.FDR <- p.adjust(Signif.TESLGenes$p,method="fdr",length(Signif.TESLGenes$p)) # FDR Adjustment for multiple testing
CorTESLGenes.FDRadj <- CorTES.LGenes
CorTESLGenes.FDRadj[TESLGenes.padj.FDR>0.05] <- 0
degrees <- getDegree(CorTESLGenes.FDRadj)
degrees$epi
getDegree <- function(corMatrix) {
deg.row <- as.numeric()
for(k in 1:nrow(corMatrix)){
deg.row[k] <- length(which(corMatrix[k,] != 0))
}
#dim(deg.row) <- length(deg.row)
names(deg.row) <- rownames(corMatrix)
# cols
deg.col <- as.numeric()
for(k in 1:ncol(corMatrix)){
deg.col[k] <- length(which(corMatrix[,k] != 0))
}
#dim(deg.col) <- length(deg.col)
names(deg.col) <- colnames(corMatrix)
result <- list(epiDegree = deg.row, stromaDegree = deg.col)
}
degrees <- getDegree(CorTESLGenes.FDRadj)
removeUnnecessaryGenes <- function(corMatrix, epiDegrees, stromaDegrees) {
for (gene in colnames(corMatrix)) {
if (epiDegrees[gene] == 0 && stromaDegrees[gene] == 0) {
corMatix <- corMatix[-gene, -gene]
}
}
corMatrix
}
tempMatrix <- removeUnnecessaryGenes(CorTESLGenes.FDRadj, degrees$epiDegree, degrees$stromaDegree)
removeUnnecessaryGenes <- function(corMatrix, epiDegrees, stromaDegrees) {
for (gene in colnames(corMatrix)) {
if (epiDegrees[gene] == 0 && stromaDegrees[gene] == 0) {
corMatix <- corMatrix[-gene, -gene]
}
}
corMatrix
}
tempMatrix <- removeUnnecessaryGenes(CorTESLGenes.FDRadj, degrees$epiDegree, degrees$stromaDegree)
removeUnnecessaryGenes <- function(corMatrix, epiDegrees, stromaDegrees) {
for (index in 1:nrow(corMatrix)) {
if (epiDegrees[index] == 0 && stromaDegrees[index] == 0) {
corMatix <- corMatrix[-index, -index]
}
}
corMatrix
}
tempMatrix <- removeUnnecessaryGenes(CorTESLGenes.FDRadj, degrees$epiDegree, degrees$stromaDegree)
