function getMinRadius(numNodes, nodeRadius) {
    return Math.max((1.3 * numNodes * (nodeRadius * 2)) / (2 * Math.PI), 120);
}


module.exports = {
    positionNodesBipartite: function(nodes, epiX, stromaX, epiY, stromaY) {
        var epiIncrement = 0;
        var stromaIncrement = 0;

        for (var i = 0; i < nodes.length; i++) {
            //console.log(nodes[i].classes);
            if (nodes[i].classes != null && nodes[i].classes.indexOf("epi") >= 0) {
                nodes[i].position = {
                    x: epiX,
                    y: epiY + (23 * epiIncrement)
                };
                epiIncrement++;
            } else {
                nodes[i].position = {
                    x: stromaX,
                    y: stromaY + (23 * stromaIncrement)
                };
                stromaIncrement++;
            }
        }
    },
    positionNodesClustered: function(selectedGene, firstNeighbours, secondNeighbours, clusterNumber, totalClusters, nodeRadius, largestClusterSize) {
        var mainRadius = (totalClusters * largestClusterSize * 1.5) / Math.PI;
        var firstNeighbourRadius = getMinRadius(firstNeighbours.length, nodeRadius);
        var secondNeighbourRadius = firstNeighbourRadius + getMinRadius(secondNeighbours.length, nodeRadius);

        //console.log("firstNeighbourRadius: " + firstNeighbourRadius);

        var selectedGeneAngle = ((2 * Math.PI) / totalClusters) * (clusterNumber + 1);

        selectedGene.position = {
            x: mainRadius * Math.cos(selectedGeneAngle),
            y: mainRadius * Math.sin(selectedGeneAngle)
        }

        for (var i = 0; i < firstNeighbours.length; i++) {
            var firstNeighbourAngle = ((2 * Math.PI) / firstNeighbours.length) * (i + 1);
            firstNeighbours[i].position = {
                x: (firstNeighbourRadius * Math.cos(firstNeighbourAngle)) + selectedGene.position.x,
                y: (firstNeighbourRadius * Math.sin(firstNeighbourAngle)) + selectedGene.position.y
            };
        }

        for (var i = 0; i < secondNeighbours.length; i++) {
            var secondNeighbourAngle = ((2 * Math.PI) / secondNeighbours.length) * i;
            secondNeighbours[i].position = {
                x: (secondNeighbourRadius * Math.cos(secondNeighbourAngle)) + selectedGene.position.x,
                y: (secondNeighbourRadius * Math.sin(secondNeighbourAngle)) + selectedGene.position.y
            };
        }

        return {
            selectedGene: selectedGene,
            firstNeighbours: firstNeighbours,
            secondNeighbours: secondNeighbours
        };
    },
    createPresetLayout: function() {
        var layout = {
            name: "preset"
        };

        return layout;
    },
    getMinRadius: getMinRadius,
    createRandomLayout: function(numNodes, nodeSize) {
        var r = nodeSize / 2;
        var areaRequired = numNodes * Math.PI * (r * r) * 40;
        var height = Math.sqrt(areaRequired / (16 / 9));
        var width = height * (16 / 9);

        //console.log("height: " + height);
        //console.log("width: " + width);
        // var width = numNodes * Math.PI * (nodeSize * nodeSize / 2) > 400 ? numNodes * nodeSize : numNodes * Math.PI * (nodeSize * nodeSize / 2);
        // var height = numNodes * Math.PI * (nodeSize * nodeSize / 2) > 300 ? numNodes * nodeSize : 300;

        var layout = {
            name: "random",
            fit: "false",
            boundingBox: { x1: 0, y1: 0, w: width, h: height }
        };

        return layout;
    }
}
